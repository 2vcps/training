# Agile Methodology
## 2015 Q2 EMC Accreditation
## Jonas Rosland & Matt Cowger

---

# Agile 101

> You can't gather all the requirements up front
 The requirements you do gather **will** change
 There is always more to do than time and money will allow

-- The Agile Samurai, J. Rasmusson

^ Open this presentation with [Deckset](http://www.decksetapp.com/).  Just keep this in mind as we go through this, as its the underpinning of everything here.

---

# How bad is it?

> 18% of software projects are considered "failed", 43% "challenged"

> 39% actually succeeding

-- 2012 study by [The Standish Group](http://www.versionone.com/assets/img/files/CHAOSManifesto2013.pdf)

^ So whats actually driving this?  Why are companies flocking to agile methods?  Its because the current methods aren't working - they aren't scaling.

---

# What can happen without Agile?

* Software projects aren't delivered on time to market
* Requirements not met with high cost to make changes after delivery
* Having to “get it right” first time/up front is really hard

---

# Unhappy Customers and Developers
![](http://www.therelationalmarketer.com/wp-content/uploads/2009/02/11389_0_Fotolia_11045915_Subscription_L1.jpg)

---

# Software Development Methodologies
* "Code-fix” (or no process)
* Structured, heavy weight methodologies a.k.a.
“Plan Driven Methodologies” and “Waterfall”

^ If you dont have any real process at all, you have a code-fix process, wherein you 'write code' then 'fix it' repeatedly.  Perhaps you are beyond that, and you've gone to a process where you gather requirements, and follow a very specific methodlogy....If so, its probably a variant of waterfall.

---

# Traditional Waterfall Process

---

![](http://i.ytimg.com/vi/_ZKvvaZEFKE/maxresdefault.jpg)

---

# Waterfall Methodology

* Largely influenced by _traditional engineering_ and _quality processes_ in industries
* Desire to make software development more _predictable_, _measurable_ and _efficient_
* Strong emphasis on _detailed planning_ and then _executing to the plan_

---

# But Software is Different

* Is not tangible
* Is not based on mathematics
* Needs knowledge workers

^ Its far too fluid and changing compared to math or engineering, and knowledge workers aren't a fungible resource!

---

# Relevance
###Heavy weight methodologies are most successful when:

 - Requirements are stable
 - Technology is well known and mature
 - Everything happens as one would expect
 - We are not taking on anything new or unknown
 - Coding is ‘copy and paste’

---

# That's just not true for most modern projects

---

# Origins Of Agile

###Agile Methods are a reaction to:

* Rigidity of heavy weight methods
* Bureaucracy introduced by heavy weight methods
* Unpleasant surprises due to lack of visibility
* **The myth that a well defined process is more valuable than the people who use it**

---

# Agile Follows Systems Thinking
* System Thinking is a way of looking at how things influence each other as a whole and not as individual parts
* Focus on Flow, not Function
* Look at the end-to-end process and the value we deliver to our customers
  * What do our customers value
  * How do we respond to the demands from our customers, as a system

---

# Agile Follows Lean Thinking
* Add nothing but value (eliminate waste)
* Flow value from demand (delay commitment)
* Minimize inventory (minimize intermediate artifacts)
* Optimize across the organization

^ this originally comes from the manfacturing world, lest you think it doesn't apply outside software development.

---

![fit](http://www.flockofbirds.nl/wp/wp-content/uploads/2014/03/Agile-Development-Diagram.jpg)

---

# The Agile Manifesto

---

>We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value:

* **Individuals and interactions** over _processes and tools_
* **Working software** over _comprehensive documentation_
* **Customer collaboration** over _contract negotiation_
* **Responding to change** over _following a plan_.

>That is, while there is value in the items on _the right_,
we value the **items on the left** more.

---

#12 Principles of Agile

* Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.
* Welcome changing requirements, even late in development.
* Deliver working software frequently, with a preference to the shorter timescale.

^ customer needs are the most important.
^ late requirements are OK if we can handle them without friction
^ minimum viable product.  working partially the wrong way is better than non working perfection.

---

#12 Principles of Agile (cont)

* Business people and developers must work together throughout the project.
* Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.
* The most efficient and effective method of conveying information is face-to-face conversation.

^ If biz+devs dont work together, they dont align on goals.  In EMC, we call this 'compensation drives behavior'
^ *people* are at the center, and will drive happy teams.  This comes form the ground up, not top down.
^ nothing is better than standing in front of each other.  video conferences as a next best.

---

#12 Principles of Agile (cont)

* Working software is the primary measure of progress.
* Agile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.
* Continuous attention to technical excellence and good design enhances agility.

^ working > *
^ prevent heros.  heros are bad because they burn out. (mention phoenix project)
^ avoid technical debt.

---

#12 Principles of Agile (cont)

* Simplicity - the art of maximizing the amount of work not done - is essential.
* The best architectures, requirements, and designs emerge from self-organizing teams.
* At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behaviour accordingly.

^ simplicity also drives the ability to change quickly.
^ teams building, not highlevel arch teams, determine the best methods.
^ agile itself is iterated.

---

# Minimum Viable Product (MVP)

![inline](../devops-geekweek/images/mvp_fail_01.png)

^ In this example, we build 5 new products...does that possibly take more overall work?  Maybe, but we make revenue the WHOLE TIME, not just after step 4, when its expensive to fail. 

---

# Agile Myths

* No Planning
* No Documentation
* Lacks Discipline
* Limited to Co-Located Teams
* Open Ended

^ There's a ton of planning, its just done for shorter time frames
^ There's documentation in all of the discussions done by the team in the Kanban boards and the code.  The lack of a 'master plan' is a positive.
^ It requires more discipline to follow this and trust your team...
^ Colocated teams are easier (especially newbies), but remote teams can be done with modern tools (look for our other course)
^ Agile is indeed open ended, in that we are always looking to iterate.  Its not open ended with working software, which is delivered at the end of every sprint.  We only commit to what we can finish.

---
